!(function (t, e) { typeof define === 'function' && define.amd ? define([], e) : typeof exports === 'object' ? module.exports = e() : t.Tether = e(); }(this, () => {
  function t(t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function'); } function e(t) { const o = t.getBoundingClientRect(); const i = {}; for (const n in o)i[n] = o[n]; try { if (t.ownerDocument !== document) { const r = t.ownerDocument.defaultView.frameElement; if (r) { const s = e(r); i.top += s.top, i.bottom += s.top, i.left += s.left, i.right += s.left; } } } catch (a) {} return i; } function o(t) { const e = getComputedStyle(t) || {}; const o = e.position; const i = []; if (o === 'fixed') return [t]; for (let n = t; (n = n.parentNode) && n && n.nodeType === 1;) { let r = void 0; try { r = getComputedStyle(n); } catch (s) {} if (typeof r === 'undefined' || r === null) return i.push(n), i; const a = r; const f = a.overflow; const l = a.overflowX; const h = a.overflowY; /(auto|scroll|overlay)/.test(f + h + l) && (o !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(r.position) >= 0) && i.push(n); } return i.push(t.ownerDocument.body), t.ownerDocument !== document && i.push(t.ownerDocument.defaultView), i; } function i() { O && document.body.removeChild(O), O = null; } function n(t) { let o = void 0; t === document ? (o = document, t = document.documentElement) : o = t.ownerDocument; const i = o.documentElement; const n = e(t); const r = A(); return n.top -= r.top, n.left -= r.left, typeof n.width === 'undefined' && (n.width = document.body.scrollWidth - n.left - n.right), typeof n.height === 'undefined' && (n.height = document.body.scrollHeight - n.top - n.bottom), n.top -= i.clientTop, n.left -= i.clientLeft, n.right = o.body.clientWidth - n.width - n.left, n.bottom = o.body.clientHeight - n.height - n.top, n; } function r(t) { return t.offsetParent || document.documentElement; } function s() {
    if (T) return T; const t = document.createElement('div'); t.style.width = '100%', t.style.height = '200px'; const e = document.createElement('div'); a(e.style, {
      position: 'absolute', top: 0, left: 0, pointerEvents: 'none', visibility: 'hidden', width: '200px', height: '150px', overflow: 'hidden',
    }), e.appendChild(t), document.body.appendChild(e); const o = t.offsetWidth; e.style.overflow = 'scroll'; let i = t.offsetWidth; o === i && (i = e.clientWidth), document.body.removeChild(e); const n = o - i; return T = { width: n, height: n };
  } function a() { const t = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0]; const e = []; return Array.prototype.push.apply(e, arguments), e.slice(1).forEach((e) => { if (e) for (const o in e)({}).hasOwnProperty.call(e, o) && (t[o] = e[o]); }), t; } function f(t, e) { if (typeof t.classList !== 'undefined')e.split(' ').forEach((e) => { e.trim() && t.classList.remove(e); }); else { const o = new RegExp(`(^| )${e.split(' ').join('|')}( |$)`, 'gi'); const i = d(t).replace(o, ' '); u(t, i); } } function l(t, e) { if (typeof t.classList !== 'undefined')e.split(' ').forEach((e) => { e.trim() && t.classList.add(e); }); else { f(t, e); const o = `${d(t)} ${e}`; u(t, o); } } function h(t, e) { if (typeof t.classList !== 'undefined') return t.classList.contains(e); const o = d(t); return new RegExp(`(^| )${e}( |$)`, 'gi').test(o); } function d(t) { return t.className instanceof t.ownerDocument.defaultView.SVGAnimatedString ? t.className.baseVal : t.className; } function u(t, e) { t.setAttribute('class', e); } function p(t, e, o) { o.forEach((o) => { e.indexOf(o) === -1 && h(t, o) && f(t, o); }), e.forEach((e) => { h(t, e) || l(t, e); }); } function t(t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function'); } function c(t, e) {
    if (typeof e !== 'function' && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t, enumerable: !1, writable: !0, configurable: !0,
      },
    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  } function g(t, e) { const o = arguments.length <= 2 || void 0 === arguments[2] ? 1 : arguments[2]; return t + o >= e && e >= t - o; } function m() { return typeof performance === 'object' && typeof performance.now === 'function' ? performance.now() : +new Date(); } function v() { for (var t = { top: 0, left: 0 }, e = arguments.length, o = Array(e), i = 0; i < e; i++)o[i] = arguments[i]; return o.forEach((e) => { let o = e.top; let i = e.left; typeof o === 'string' && (o = parseFloat(o, 10)), typeof i === 'string' && (i = parseFloat(i, 10)), t.top += o, t.left += i; }), t; } function y(t, e) { return typeof t.left === 'string' && t.left.indexOf('%') !== -1 && (t.left = parseFloat(t.left, 10) / 100 * e.width), typeof t.top === 'string' && t.top.indexOf('%') !== -1 && (t.top = parseFloat(t.top, 10) / 100 * e.height), t; } function b(t, e) { return e === 'scrollParent' ? e = t.scrollParents[0] : e === 'window' && (e = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset]), e === document && (e = e.documentElement), typeof e.nodeType !== 'undefined' && !(function () { const t = e; const o = n(e); const i = o; const r = getComputedStyle(e); if (e = [i.left, i.top, o.width + i.left, o.height + i.top], t.ownerDocument !== document) { const s = t.ownerDocument.defaultView; e[0] += s.pageXOffset, e[1] += s.pageYOffset, e[2] += s.pageXOffset, e[3] += s.pageYOffset; }I.forEach((t, o) => { t = t[0].toUpperCase() + t.substr(1), t === 'Top' || t === 'Left' ? e[o] += parseFloat(r[`border${t}Width`]) : e[o] -= parseFloat(r[`border${t}Width`]); }); }()), e; } var w = (function () { function t(t, e) { for (let o = 0; o < e.length; o++) { const i = e[o]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(t, i.key, i); } } return function (e, o, i) { return o && t(e.prototype, o), i && t(e, i), e; }; }()); let C = void 0; typeof C === 'undefined' && (C = { modules: [] }); var O = null; const E = (function () { let t = 0; return function () { return ++t; }; }()); const x = {}; var A = function () { let t = O; t && document.body.contains(t) || (t = document.createElement('div'), t.setAttribute('data-tether-id', E()), a(t.style, { top: 0, left: 0, position: 'absolute' }), document.body.appendChild(t), O = t); const o = t.getAttribute('data-tether-id'); return typeof x[o] === 'undefined' && (x[o] = e(t), S(() => { delete x[o]; })), x[o]; }; var T = null; const P = []; var S = function (t) { P.push(t); }; var W = function () { for (let t = void 0; t = P.pop();)t(); }; const M = (function () { function e() { t(this, e); } return w(e, [{ key: 'on', value(t, e, o) { const i = !(arguments.length <= 3 || void 0 === arguments[3]) && arguments[3]; typeof this.bindings === 'undefined' && (this.bindings = {}), typeof this.bindings[t] === 'undefined' && (this.bindings[t] = []), this.bindings[t].push({ handler: e, ctx: o, once: i }); } }, { key: 'once', value(t, e, o) { this.on(t, e, o, !0); } }, { key: 'off', value(t, e) { if (typeof this.bindings !== 'undefined' && typeof this.bindings[t] !== 'undefined') if (typeof e === 'undefined') delete this.bindings[t]; else for (let o = 0; o < this.bindings[t].length;) this.bindings[t][o].handler === e ? this.bindings[t].splice(o, 1) : ++o; } }, { key: 'trigger', value(t) { if (typeof this.bindings !== 'undefined' && this.bindings[t]) { for (var e = 0, o = arguments.length, i = Array(o > 1 ? o - 1 : 0), n = 1; n < o; n++)i[n - 1] = arguments[n]; for (;e < this.bindings[t].length;) { const r = this.bindings[t][e]; const s = r.handler; const a = r.ctx; const f = r.once; let l = a; typeof l === 'undefined' && (l = this), s.apply(l, i), f ? this.bindings[t].splice(e, 1) : ++e; } } } }]), e; }()); C.Utils = {
    getActualBoundingClientRect: e, getScrollParents: o, getBounds: n, getOffsetParent: r, extend: a, addClass: l, removeClass: f, hasClass: h, updateClasses: p, defer: S, flush: W, uniqueId: E, Evented: M, getScrollBarSize: s, removeUtilElements: i,
  }; var k = (function () { function t(t, e) { const o = []; let i = !0; let n = !1; let r = void 0; try { for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (o.push(s.value), !e || o.length !== e); i = !0); } catch (f) { n = !0, r = f; } finally { try { !i && a.return && a.return(); } finally { if (n) throw r; } } return o; } return function (e, o) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, o); throw new TypeError('Invalid attempt to destructure non-iterable instance'); }; }()); var w = (function () { function t(t, e) { for (let o = 0; o < e.length; o++) { const i = e[o]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(t, i.key, i); } } return function (e, o, i) { return o && t(e.prototype, o), i && t(e, i), e; }; }()); const _ = function (t, e, o) { for (let i = !0; i;) { let n = t; const r = e; const s = o; i = !1, n === null && (n = Function.prototype); let a = Object.getOwnPropertyDescriptor(n, r); if (void 0 !== a) { if ('value' in a) return a.value; const f = a.get; if (void 0 === f) return; return f.call(s); } let l = Object.getPrototypeOf(n); if (l === null) return; t = l, e = r, o = s, i = !0, a = l = void 0; } }; if (typeof C === 'undefined') throw new Error('You must include the utils.js file before tether.js'); var z = C.Utils; var o = z.getScrollParents; var n = z.getBounds; var r = z.getOffsetParent; var a = z.extend; var l = z.addClass; var f = z.removeClass; var p = z.updateClasses; var S = z.defer; var W = z.flush; var s = z.getScrollBarSize; var i = z.removeUtilElements; const B = (function () { if (typeof document === 'undefined') return ''; for (let t = document.createElement('div'), e = ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform'], o = 0; o < e.length; ++o) { const i = e[o]; if (void 0 !== t.style[i]) return i; } }()); const j = []; const F = function () { j.forEach((t) => { t.position(!1); }), W(); }; !(function () { let t = null; let e = null; let o = null; const i = function n() { return typeof e !== 'undefined' && e > 16 ? (e = Math.min(e - 16, 250), void (o = setTimeout(n, 250))) : void (typeof t !== 'undefined' && m() - t < 10 || (o != null && (clearTimeout(o), o = null), t = m(), F(), e = m() - t)); }; typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined' && ['resize', 'scroll', 'touchmove'].forEach((t) => { window.addEventListener(t, i); }); }()); const Y = { center: 'center', left: 'right', right: 'left' }; const D = { middle: 'middle', top: 'bottom', bottom: 'top' }; const L = {
    top: 0, left: 0, middle: '50%', center: '50%', bottom: '100%', right: '100%',
  }; const X = function (t, e) { let o = t.left; let i = t.top; return o === 'auto' && (o = Y[e.left]), i === 'auto' && (i = D[e.top]), { left: o, top: i }; }; const H = function (t) { let e = t.left; let o = t.top; return typeof L[t.left] !== 'undefined' && (e = L[t.left]), typeof L[t.top] !== 'undefined' && (o = L[t.top]), { left: e, top: o }; }; const N = function (t) { const e = t.split(' '); const o = k(e, 2); const i = o[0]; const n = o[1]; return { top: i, left: n }; }; const R = N; const U = (function (e) {
    function h(e) { const o = this; t(this, h), _(Object.getPrototypeOf(h.prototype), 'constructor', this).call(this), this.position = this.position.bind(this), j.push(this), this.history = [], this.setOptions(e, !1), C.modules.forEach((t) => { typeof t.initialize !== 'undefined' && t.initialize.call(o); }), this.position(); } return c(h, e), w(h, [{ key: 'getClass', value() { const t = arguments.length <= 0 || void 0 === arguments[0] ? '' : arguments[0]; const e = this.options.classes; return typeof e !== 'undefined' && e[t] ? this.options.classes[t] : this.options.classPrefix ? `${this.options.classPrefix}-${t}` : t; } }, {
      key: 'setOptions',
      value(t) {
        const e = this; const i = arguments.length <= 1 || void 0 === arguments[1] || arguments[1]; const n = {
          offset: '0 0', targetOffset: '0 0', targetAttachment: 'auto auto', classPrefix: 'tether',
        }; this.options = a(n, t); const r = this.options; const s = r.element; const f = r.target; const h = r.targetModifier; if (this.element = s, this.target = f, this.targetModifier = h, this.target === 'viewport' ? (this.target = document.body, this.targetModifier = 'visible') : this.target === 'scroll-handle' && (this.target = document.body, this.targetModifier = 'scroll-handle'), ['element', 'target'].forEach((t) => { if (typeof e[t] === 'undefined') throw new Error('Tether Error: Both element and target must be defined'); typeof e[t].jquery !== 'undefined' ? e[t] = e[t][0] : typeof e[t] === 'string' && (e[t] = document.querySelector(e[t])); }), l(this.element, this.getClass('element')), this.options.addTargetClasses !== !1 && l(this.target, this.getClass('target')), !this.options.attachment) throw new Error('Tether Error: You must provide an attachment'); this.targetAttachment = R(this.options.targetAttachment), this.attachment = R(this.options.attachment), this.offset = N(this.options.offset), this.targetOffset = N(this.options.targetOffset), typeof this.scrollParents !== 'undefined' && this.disable(), this.targetModifier === 'scroll-handle' ? this.scrollParents = [this.target] : this.scrollParents = o(this.target), this.options.enabled !== !1 && this.enable(i);
      },
    }, {
      key: 'getTargetBounds',
      value() {
        if (typeof this.targetModifier === 'undefined') return n(this.target); if (this.targetModifier === 'visible') {
          if (this.target === document.body) {
            return {
              top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth,
            };
          } var t = n(this.target); var e = {
            height: t.height, width: t.width, top: t.top, left: t.left,
          }; return e.height = Math.min(e.height, t.height - (pageYOffset - t.top)), e.height = Math.min(e.height, t.height - (t.top + t.height - (pageYOffset + innerHeight))), e.height = Math.min(innerHeight, e.height), e.height -= 2, e.width = Math.min(e.width, t.width - (pageXOffset - t.left)), e.width = Math.min(e.width, t.width - (t.left + t.width - (pageXOffset + innerWidth))), e.width = Math.min(innerWidth, e.width), e.width -= 2, e.top < pageYOffset && (e.top = pageYOffset), e.left < pageXOffset && (e.left = pageXOffset), e;
        } if (this.targetModifier === 'scroll-handle') {
          var t = void 0; let o = this.target; o === document.body ? (o = document.documentElement, t = {
            left: pageXOffset, top: pageYOffset, height: innerHeight, width: innerWidth,
          }) : t = n(o); const i = getComputedStyle(o); const r = o.scrollWidth > o.clientWidth || [i.overflow, i.overflowX].indexOf('scroll') >= 0 || this.target !== document.body; let s = 0; r && (s = 15); const a = t.height - parseFloat(i.borderTopWidth) - parseFloat(i.borderBottomWidth) - s; var e = { width: 15, height: 0.975 * a * (a / o.scrollHeight), left: t.left + t.width - parseFloat(i.borderLeftWidth) - 15 }; let f = 0; a < 408 && this.target === document.body && (f = -11e-5 * Math.pow(a, 2) - 0.00727 * a + 22.58), this.target !== document.body && (e.height = Math.max(e.height, 24)); const l = this.target.scrollTop / (o.scrollHeight - a); return e.top = l * (a - e.height - f) + t.top + parseFloat(i.borderTopWidth), this.target === document.body && (e.height = Math.max(e.height, 24)), e;
        }
      },
    }, { key: 'clearCache', value() { this._cache = {}; } }, { key: 'cache', value(t, e) { return typeof this._cache === 'undefined' && (this._cache = {}), typeof this._cache[t] === 'undefined' && (this._cache[t] = e.call(this)), this._cache[t]; } }, { key: 'enable', value() { const t = this; const e = arguments.length <= 0 || void 0 === arguments[0] || arguments[0]; this.options.addTargetClasses !== !1 && l(this.target, this.getClass('enabled')), l(this.element, this.getClass('enabled')), this.enabled = !0, this.scrollParents.forEach((e) => { e !== t.target.ownerDocument && e.addEventListener('scroll', t.position); }), e && this.position(); } }, { key: 'disable', value() { const t = this; f(this.target, this.getClass('enabled')), f(this.element, this.getClass('enabled')), this.enabled = !1, typeof this.scrollParents !== 'undefined' && this.scrollParents.forEach((e) => { e.removeEventListener('scroll', t.position); }); } }, { key: 'destroy', value() { const t = this; this.disable(), j.forEach((e, o) => { e === t && j.splice(o, 1); }), j.length === 0 && i(); } }, { key: 'updateAttachClasses', value(t, e) { const o = this; t = t || this.attachment, e = e || this.targetAttachment; const i = ['left', 'top', 'bottom', 'right', 'middle', 'center']; typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length && this._addAttachClasses.splice(0, this._addAttachClasses.length), typeof this._addAttachClasses === 'undefined' && (this._addAttachClasses = []); const n = this._addAttachClasses; t.top && n.push(`${this.getClass('element-attached')}-${t.top}`), t.left && n.push(`${this.getClass('element-attached')}-${t.left}`), e.top && n.push(`${this.getClass('target-attached')}-${e.top}`), e.left && n.push(`${this.getClass('target-attached')}-${e.left}`); const r = []; i.forEach((t) => { r.push(`${o.getClass('element-attached')}-${t}`), r.push(`${o.getClass('target-attached')}-${t}`); }), S(() => { typeof o._addAttachClasses !== 'undefined' && (p(o.element, o._addAttachClasses, r), o.options.addTargetClasses !== !1 && p(o.target, o._addAttachClasses, r), delete o._addAttachClasses); }); } }, {
      key: 'position',
      value() {
        const t = this; const e = arguments.length <= 0 || void 0 === arguments[0] || arguments[0]; if (this.enabled) {
          this.clearCache(); const o = X(this.targetAttachment, this.attachment); this.updateAttachClasses(this.attachment, o); const i = this.cache('element-bounds', () => n(t.element)); let a = i.width; let f = i.height; if (a === 0 && f === 0 && typeof this.lastSize !== 'undefined') { const l = this.lastSize; a = l.width, f = l.height; } else this.lastSize = { width: a, height: f }; const h = this.cache('target-bounds', () => t.getTargetBounds()); const d = h; let u = y(H(this.attachment), { width: a, height: f }); let p = y(H(o), d); const c = y(this.offset, { width: a, height: f }); const g = y(this.targetOffset, d); u = v(u, c), p = v(p, g); for (var m = h.left + p.left - u.left, b = h.top + p.top - u.top, w = 0; w < C.modules.length; ++w) {
            const O = C.modules[w]; const E = O.position.call(this, {
              left: m, top: b, targetAttachment: o, targetPos: h, elementPos: i, offset: u, targetOffset: p, manualOffset: c, manualTargetOffset: g, scrollbarSize: P, attachment: this.attachment,
            }); if (E === !1) return !1; typeof E !== 'undefined' && typeof E === 'object' && (b = E.top, m = E.left);
          } const x = {
            page: { top: b, left: m },
            viewport: {
              top: b - pageYOffset, bottom: pageYOffset - b - f + innerHeight, left: m - pageXOffset, right: pageXOffset - m - a + innerWidth,
            },
          }; const A = this.target.ownerDocument; const T = A.defaultView; var P = void 0; return T.innerHeight > A.documentElement.clientHeight && (P = this.cache('scrollbar-size', s), x.viewport.bottom -= P.height), T.innerWidth > A.documentElement.clientWidth && (P = this.cache('scrollbar-size', s), x.viewport.right -= P.width), ['', 'static'].indexOf(A.body.style.position) !== -1 && ['', 'static'].indexOf(A.body.parentElement.style.position) !== -1 || (x.page.bottom = A.body.scrollHeight - b - f, x.page.right = A.body.scrollWidth - m - a), typeof this.options.optimizations !== 'undefined' && this.options.optimizations.moveElement !== !1 && typeof this.targetModifier === 'undefined' && !(function () { const e = t.cache('target-offsetparent', () => r(t.target)); const o = t.cache('target-offsetparent-bounds', () => n(e)); const i = getComputedStyle(e); const s = o; const a = {}; if (['Top', 'Left', 'Bottom', 'Right'].forEach((t) => { a[t.toLowerCase()] = parseFloat(i[`border${t}Width`]); }), o.right = A.body.scrollWidth - o.left - s.width + a.right, o.bottom = A.body.scrollHeight - o.top - s.height + a.bottom, x.page.top >= o.top + a.top && x.page.bottom >= o.bottom && x.page.left >= o.left + a.left && x.page.right >= o.right) { const f = e.scrollTop; const l = e.scrollLeft; x.offset = { top: x.page.top - o.top + f - a.top, left: x.page.left - o.left + l - a.left }; } }()), this.move(x), this.history.unshift(x), this.history.length > 3 && this.history.pop(), e && W(), !0;
        }
      },
    }, {
      key: 'move',
      value(t) {
        const e = this; if (typeof this.element.parentNode !== 'undefined') {
          const o = {}; for (const i in t) { o[i] = {}; for (var n in t[i]) { for (var s = !1, f = 0; f < this.history.length; ++f) { const l = this.history[f]; if (typeof l[i] !== 'undefined' && !g(l[i][n], t[i][n])) { s = !0; break; } }s || (o[i][n] = !0); } } const h = {
            top: '', left: '', right: '', bottom: '',
          }; const d = function (t, o) { const i = typeof e.options.optimizations !== 'undefined'; const n = i ? e.options.optimizations.gpu : null; if (n !== !1) { let r = void 0; let s = void 0; t.top ? (h.top = 0, r = o.top) : (h.bottom = 0, r = -o.bottom), t.left ? (h.left = 0, s = o.left) : (h.right = 0, s = -o.right), typeof window.devicePixelRatio === 'number' && devicePixelRatio % 1 === 0 && (s = Math.round(s * devicePixelRatio) / devicePixelRatio, r = Math.round(r * devicePixelRatio) / devicePixelRatio), h[B] = `translateX(${s}px) translateY(${r}px)`, B !== 'msTransform' && (h[B] += ' translateZ(0)'); } else t.top ? h.top = `${o.top}px` : h.bottom = `${o.bottom}px`, t.left ? h.left = `${o.left}px` : h.right = `${o.right}px`; }; let u = !1; if ((o.page.top || o.page.bottom) && (o.page.left || o.page.right) ? (h.position = 'absolute', d(o.page, t.page)) : (o.viewport.top || o.viewport.bottom) && (o.viewport.left || o.viewport.right) ? (h.position = 'fixed', d(o.viewport, t.viewport)) : typeof o.offset !== 'undefined' && o.offset.top && o.offset.left ? !(function () { h.position = 'absolute'; const i = e.cache('target-offsetparent', () => r(e.target)); r(e.element) !== i && S(() => { e.element.parentNode.removeChild(e.element), i.appendChild(e.element); }), d(o.offset, t.offset), u = !0; }()) : (h.position = 'absolute', d({ top: !0, left: !0 }, t.page)), !u) if (this.options.bodyElement) this.element.parentNode !== this.options.bodyElement && this.options.bodyElement.appendChild(this.element); else { for (var p = function (t) { const e = t.ownerDocument; const o = e.fullscreenElement || e.webkitFullscreenElement || e.mozFullScreenElement || e.msFullscreenElement; return o === t; }, c = !0, m = this.element.parentNode; m && m.nodeType === 1 && m.tagName !== 'BODY' && !p(m);) { if (getComputedStyle(m).position !== 'static') { c = !1; break; }m = m.parentNode; }c || (this.element.parentNode.removeChild(this.element), this.element.ownerDocument.body.appendChild(this.element)); } const v = {}; let y = !1; for (var n in h) { const b = h[n]; const w = this.element.style[n]; w !== b && (y = !0, v[n] = b); }y && S(() => { a(e.element.style, v), e.trigger('repositioned'); });
        }
      },
    }]), h;
  }(M)); U.modules = [], C.position = F; const V = a(U, C); var k = (function () { function t(t, e) { const o = []; let i = !0; let n = !1; let r = void 0; try { for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (o.push(s.value), !e || o.length !== e); i = !0); } catch (f) { n = !0, r = f; } finally { try { !i && a.return && a.return(); } finally { if (n) throw r; } } return o; } return function (e, o) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, o); throw new TypeError('Invalid attempt to destructure non-iterable instance'); }; }()); var z = C.Utils; var n = z.getBounds; var a = z.extend; var p = z.updateClasses; var S = z.defer; var I = ['left', 'top', 'right', 'bottom']; C.modules.push({ position(t) { const e = this; let o = t.top; let i = t.left; const r = t.targetAttachment; if (!this.options.constraints) return !0; const s = this.cache('element-bounds', () => n(e.element)); let f = s.height; let l = s.width; if (l === 0 && f === 0 && typeof this.lastSize !== 'undefined') { const h = this.lastSize; l = h.width, f = h.height; } const d = this.cache('target-bounds', () => e.getTargetBounds()); const u = d.height; const c = d.width; const g = [this.getClass('pinned'), this.getClass('out-of-bounds')]; this.options.constraints.forEach((t) => { const e = t.outOfBoundsClass; const o = t.pinnedClass; e && g.push(e), o && g.push(o); }), g.forEach((t) => { ['left', 'top', 'right', 'bottom'].forEach((e) => { g.push(`${t}-${e}`); }); }); const m = []; const v = a({}, r); const y = a({}, this.attachment); return this.options.constraints.forEach((t) => { const n = t.to; let s = t.attachment; let a = t.pin; typeof s === 'undefined' && (s = ''); let h = void 0; let d = void 0; if (s.indexOf(' ') >= 0) { const p = s.split(' '); const g = k(p, 2); d = g[0], h = g[1]; } else h = d = s; const w = b(e, n); d !== 'target' && d !== 'both' || (o < w[1] && v.top === 'top' && (o += u, v.top = 'bottom'), o + f > w[3] && v.top === 'bottom' && (o -= u, v.top = 'top')), d === 'together' && (v.top === 'top' && (y.top === 'bottom' && o < w[1] ? (o += u, v.top = 'bottom', o += f, y.top = 'top') : y.top === 'top' && o + f > w[3] && o - (f - u) >= w[1] && (o -= f - u, v.top = 'bottom', y.top = 'bottom')), v.top === 'bottom' && (y.top === 'top' && o + f > w[3] ? (o -= u, v.top = 'top', o -= f, y.top = 'bottom') : y.top === 'bottom' && o < w[1] && o + (2 * f - u) <= w[3] && (o += f - u, v.top = 'top', y.top = 'top')), v.top === 'middle' && (o + f > w[3] && y.top === 'top' ? (o -= f, y.top = 'bottom') : o < w[1] && y.top === 'bottom' && (o += f, y.top = 'top'))), h !== 'target' && h !== 'both' || (i < w[0] && v.left === 'left' && (i += c, v.left = 'right'), i + l > w[2] && v.left === 'right' && (i -= c, v.left = 'left')), h === 'together' && (i < w[0] && v.left === 'left' ? y.left === 'right' ? (i += c, v.left = 'right', i += l, y.left = 'left') : y.left === 'left' && (i += c, v.left = 'right', i -= l, y.left = 'right') : i + l > w[2] && v.left === 'right' ? y.left === 'left' ? (i -= c, v.left = 'left', i -= l, y.left = 'right') : y.left === 'right' && (i -= c, v.left = 'left', i += l, y.left = 'left') : v.left === 'center' && (i + l > w[2] && y.left === 'left' ? (i -= l, y.left = 'right') : i < w[0] && y.left === 'right' && (i += l, y.left = 'left'))), d !== 'element' && d !== 'both' || (o < w[1] && y.top === 'bottom' && (o += f, y.top = 'top'), o + f > w[3] && y.top === 'top' && (o -= f, y.top = 'bottom')), h !== 'element' && h !== 'both' || (i < w[0] && (y.left === 'right' ? (i += l, y.left = 'left') : y.left === 'center' && (i += l / 2, y.left = 'left')), i + l > w[2] && (y.left === 'left' ? (i -= l, y.left = 'right') : y.left === 'center' && (i -= l / 2, y.left = 'right'))), typeof a === 'string' ? a = a.split(',').map((t) => t.trim()) : a === !0 && (a = ['top', 'left', 'right', 'bottom']), a = a || []; const C = []; const O = []; o < w[1] && (a.indexOf('top') >= 0 ? (o = w[1], C.push('top')) : O.push('top')), o + f > w[3] && (a.indexOf('bottom') >= 0 ? (o = w[3] - f, C.push('bottom')) : O.push('bottom')), i < w[0] && (a.indexOf('left') >= 0 ? (i = w[0], C.push('left')) : O.push('left')), i + l > w[2] && (a.indexOf('right') >= 0 ? (i = w[2] - l, C.push('right')) : O.push('right')), C.length && !(function () { let t = void 0; t = typeof e.options.pinnedClass !== 'undefined' ? e.options.pinnedClass : e.getClass('pinned'), m.push(t), C.forEach((e) => { m.push(`${t}-${e}`); }); }()), O.length && !(function () { let t = void 0; t = typeof e.options.outOfBoundsClass !== 'undefined' ? e.options.outOfBoundsClass : e.getClass('out-of-bounds'), m.push(t), O.forEach((e) => { m.push(`${t}-${e}`); }); }()), (C.indexOf('left') >= 0 || C.indexOf('right') >= 0) && (y.left = v.left = !1), (C.indexOf('top') >= 0 || C.indexOf('bottom') >= 0) && (y.top = v.top = !1), v.top === r.top && v.left === r.left && y.top === e.attachment.top && y.left === e.attachment.left || (e.updateAttachClasses(y, v), e.trigger('update', { attachment: y, targetAttachment: v })); }), S(() => { e.options.addTargetClasses !== !1 && p(e.target, m, g), p(e.element, m, g); }), { top: o, left: i }; } }); var z = C.Utils; var n = z.getBounds; var p = z.updateClasses; var S = z.defer; C.modules.push({ position(t) { const e = this; const o = t.top; const i = t.left; const r = this.cache('element-bounds', () => n(e.element)); const s = r.height; const a = r.width; const f = this.getTargetBounds(); const l = o + s; const h = i + a; const d = []; o <= f.bottom && l >= f.top && ['left', 'right'].forEach((t) => { const e = f[t]; e !== i && e !== h || d.push(t); }), i <= f.right && h >= f.left && ['top', 'bottom'].forEach((t) => { const e = f[t]; e !== o && e !== l || d.push(t); }); const u = []; const c = []; const g = ['left', 'top', 'right', 'bottom']; return u.push(this.getClass('abutted')), g.forEach((t) => { u.push(`${e.getClass('abutted')}-${t}`); }), d.length && c.push(this.getClass('abutted')), d.forEach((t) => { c.push(`${e.getClass('abutted')}-${t}`); }), S(() => { e.options.addTargetClasses !== !1 && p(e.target, c, u), p(e.element, c, u); }), !0; } }); var k = (function () { function t(t, e) { const o = []; let i = !0; let n = !1; let r = void 0; try { for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (o.push(s.value), !e || o.length !== e); i = !0); } catch (f) { n = !0, r = f; } finally { try { !i && a.return && a.return(); } finally { if (n) throw r; } } return o; } return function (e, o) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, o); throw new TypeError('Invalid attempt to destructure non-iterable instance'); }; }()); return C.modules.push({ position(t) { let e = t.top; let o = t.left; if (this.options.shift) { let i = this.options.shift; typeof this.options.shift === 'function' && (i = this.options.shift.call(this, { top: e, left: o })); let n = void 0; let r = void 0; if (typeof i === 'string') { i = i.split(' '), i[1] = i[1] || i[0]; const s = i; const a = k(s, 2); n = a[0], r = a[1], n = parseFloat(n, 10), r = parseFloat(r, 10); } else n = i.top, r = i.left; return e += n, o += r, { top: e, left: o }; } } }), V;
}));
